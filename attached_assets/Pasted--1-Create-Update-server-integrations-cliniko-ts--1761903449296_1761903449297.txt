// 1) Create/Update: server/integrations/cliniko.ts
//------------------------------------------------
import fetch from "node-fetch";

const CLINIKO_BASE = "https://api.au4.cliniko.com/v1";
const CLINIKO_KEY = process.env.CLINIKO_API_KEY!;

function headers() {
  return {
    "Content-Type": "application/json",
    "Authorization": `Basic ${Buffer.from(CLINIKO_KEY + ":").toString("base64")}`,
    "Accept": "application/json"
  };
}

// --- Input hygiene helpers ---
export function sanitizeEmail(input?: string | null): string | null {
  if (!input) return null;
  let e = String(input).trim();
  // drop trailing punctuation artifacts users often speak
  e = e.replace(/[,\.;:!?]+$/g, "");
  // collapse whitespace
  e = e.replace(/\s+/g, "");
  // very light validation
  const ok = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e);
  return ok ? e : null;
}

export function sanitizePhoneE164AU(input?: string | null): string | null {
  if (!input) return null;
  let s = String(input).replace(/\s+/g, "");
  // Convert 04XXXXXXXX -> +614XXXXXXXX
  if (/^04\d{8}$/.test(s)) s = "+61" + s.slice(1);
  // Accept +614XXXXXXXX
  if (/^\+61\d{9}$/.test(s)) return s;
  // Accept 614XXXXXXXX -> +61...
  if (/^61\d{9}$/.test(s)) return "+" + s;
  return null; // don't pass garbage to Cliniko
}

// --- low-level fetch wrappers ---
async function clinikoGet(path: string, params?: Record<string, string>): Promise<any> {
  const url = new URL(CLINIKO_BASE + path);
  if (params) {
    Object.entries(params).forEach(([k, v]) => url.searchParams.set(k, v));
  }
  const res = await fetch(url.toString(), { method: "GET", headers: headers() });
  if (!res.ok) {
    const body = await res.text();
    throw new Error(`Cliniko GET ${url.pathname} ${res.status}: ${body}`);
  }
  return res.json();
}

async function clinikoPost(path: string, payload: any): Promise<any> {
  const res = await fetch(CLINIKO_BASE + path, {
    method: "POST",
    headers: headers(),
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    const body = await res.text();
    throw new Error(`Cliniko POST ${path} ${res.status}: ${body}`);
  }
  return res.json();
}

// --- search strategies ---
// Prefer native filters when possible, otherwise fall back to q= (free-text)
export async function findPatientByEmail(emailRaw: string) {
  const email = sanitizeEmail(emailRaw);
  if (!email) return null;

  // Strategy A: free-text search via q
  // Cliniko supports a single q param to match multiple fields
  try {
    const data = await clinikoGet("/patients", { q: email });
    if (Array.isArray(data?.patients) && data.patients.length) {
      // best-effort: exact email match from results
      return data.patients.find((p: any) => (p.email || "").toLowerCase() === email.toLowerCase()) || data.patients[0];
    }
  } catch (e) {
    // swallow and try next strategy
  }

  // Strategy B (optional): list & filter client-side if q failed
  try {
    const data = await clinikoGet("/patients", {}); // beware of large lists; paginate if needed later
    if (Array.isArray(data?.patients)) {
      return data.patients.find((p: any) => (p.email || "").toLowerCase() === email.toLowerCase()) || null;
    }
  } catch (e) {}
  return null;
}

export async function findPatientByPhone(phoneRaw: string) {
  const phone = sanitizePhoneE164AU(phoneRaw);
  if (!phone) return null;

  // Strategy: free-text q search
  try {
    const data = await clinikoGet("/patients", { q: phone });
    if (Array.isArray(data?.patients) && data.patients.length) {
      // attempt exact match across stored phone fields if available
      const exact = data.patients.find((p: any) => {
        const numbers = [
          p.phone_number,
          ...(Array.isArray(p.phone_numbers) ? p.phone_numbers.map((n: any) => n.number) : []),
        ].filter(Boolean);
        return numbers.some((n: string) => String(n).replace(/\s+/g, "") === phone);
      });
      return exact || data.patients[0];
    }
  } catch (e) {}
  return null;
}

// --- Upsert/Create patient ---
export async function getOrCreatePatient({ fullName, email: emailRaw, phone: phoneRaw }: { fullName?: string, email?: string, phone?: string }) {
  const email = sanitizeEmail(emailRaw || "");
  const phone = sanitizePhoneE164AU(phoneRaw || "");

  // Try finders first
  if (email) {
    const p = await findPatientByEmail(email);
    if (p) return p;
  }
  if (phone) {
    const p = await findPatientByPhone(phone);
    if (p) return p;
  }

  // Split name safely
  const name = (fullName || "").trim() || "New Caller";
  const [first_name, ...rest] = name.split(/\s+/);
  const last_name = rest.join(" ") || "Unknown";

  // Create payload — Cliniko requires structured fields
  const payload: any = { first_name, last_name };
  if (email) payload.email = email;
  if (phone) {
    // depending on your Cliniko account setup, you may use phone_numbers
    payload.phone_numbers = [{ label: "Mobile", number: phone }];
  }

  // If email is invalid, DO NOT send it — Cliniko returned 422 previously
  try {
    const created = await clinikoPost("/patients", payload);
    return created;
  } catch (e) {
    // If creation fails due to email, retry without email once
    const msg = String(e);
    if (/email.*invalid/i.test(msg)) {
      delete payload.email;
      const created = await clinikoPost("/patients", payload);
      return created;
    }
    throw e;
  }
}

// 2) In the booking flow (where you previously called findPatientByPhone/email/create)
//----------------------------------------------------------------
/*
import { getOrCreatePatient } from "./integrations/cliniko";
// ...
const patient = await getOrCreatePatient({
  fullName: collectedName,
  email: collectedEmail,  // raw from wizard; sanitizer runs inside
  phone: callerNumber,    // raw from Twilio; sanitizer runs inside
});
*/

// 3) In your wizard: validate email before proceeding to creation
//---------------------------------------------------------------
/*
- If sanitizeEmail(answer) returns null, prompt:
  "I might have misheard the email. Could you say it again, letter by letter?"
- Or offer SMS/email link to confirm details rather than creating immediately.
*/

// 4) Logging: replace previous Cliniko request logs with the new wrappers’ errors
//-------------------------------------------------------------------------------
/*
The new clinikoGet/clinikoPost throw clear messages like:
"Cliniko GET /patients 400: {...}"  or  "Cliniko POST /patients 422: {...}"
*/